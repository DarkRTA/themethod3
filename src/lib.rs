use std::io::Cursor;
use std::io::Read;
use std::io::Seek;
use std::io::SeekFrom;

use aes::cipher::generic_array::GenericArray;
use aes::cipher::BlockDecrypt;
use aes::cipher::BlockEncrypt;
use aes::cipher::KeyInit;
use aes::Aes128;
use log::debug;
use log::error;
use log::trace;
use log::warn;

pub fn decrypt_mogg(mogg_data: &mut [u8]) {
    
    let version = mogg_data[0];
    
    debug!("version: {}", version);

    match version {
        10 => return,
        11 => debug!("actual_key: {}", hex::encode(CTR_KEY_0B)),
        12 | 13 => debug!("HvKey: 12/13, {}", hex::encode(HV_KEY_0C)),
        14 => debug!("HvKey: 14, {}", hex::encode(HV_KEY_0E)),
        15 => debug!("HvKey: 15, {}", hex::encode(HV_KEY_0F)),
        16 => debug!("HvKey: 16, {}", hex::encode(HV_KEY_10)),
        17 => debug!("HvKey: 17, {}", hex::encode(HV_KEY_11)),
        _ => unreachable!(),
    };

    let ctr_key_0b = match mogg_data[0] {
        10 => return,
        11 => CTR_KEY_0B,
        12 | 13 => gen_key(&HV_KEY_0C, mogg_data, 12),
        14 => gen_key(&HV_KEY_0E, mogg_data, 14),
        15 => gen_key(&HV_KEY_0F, mogg_data, 15),
        16 => gen_key(&HV_KEY_10, mogg_data, 16),
        17 => gen_key(&HV_KEY_11, mogg_data, 17),
        _ => unreachable!(),
    };

    let ogg_offset =
        i32::from_le_bytes(mogg_data[4..4 + 4].try_into().unwrap()) as usize;
    let hmx_header_size =
        i32::from_le_bytes(mogg_data[16..16 + 4].try_into().unwrap()) as usize;

    let nonce_offset = 20 + hmx_header_size * 8;
    let mut nonce = [0u8; 16];
    nonce.copy_from_slice(&mogg_data[nonce_offset..nonce_offset + 16]);
    debug!("nonce: {}", hex::encode(nonce));
    let mut nonce_reversed = nonce;
    nonce_reversed.reverse();

    do_crypt(&ctr_key_0b, mogg_data, &nonce, ogg_offset);

    // check for HMXA
    if mogg_data[ogg_offset] == 0x48 {
        hmxa_to_ogg(mogg_data, ogg_offset, hmx_header_size)
    }
    // check if not OggS
    if mogg_data[ogg_offset] != 0x4f {
        mogg_data[0] = 10;
        error!("failed to decrypt mogg")
    }

    mogg_data[0] = 10;
}

const CTR_KEY_0B: [u8; 16] = [
    0x37, 0xb2, 0xe2, 0xb9, 0x1c, 0x74, 0xfa, 0x9e, 0x38, 0x81, 0x08, 0xea,
    0x36, 0x23, 0xdb, 0xe4,
];

const HV_KEY_0C: [u8; 16] = [
    0x01, 0x22, 0x00, 0x38, 0xd2, 0x01, 0x78, 0x8b, 0xdd, 0xcd, 0xd0, 0xf0,
    0xfe, 0x3e, 0x24, 0x7f,
];
const HV_KEY_0E: [u8; 16] = [
    0x51, 0x73, 0xad, 0xe5, 0xb3, 0x99, 0xb8, 0x61, 0x58, 0x1a, 0xf9, 0xb8,
    0x1e, 0xa7, 0xbe, 0xbf,
];
const HV_KEY_0F: [u8; 16] = [
    0xc6, 0x22, 0x94, 0x30, 0xd8, 0x3c, 0x84, 0x14, 0x08, 0x73, 0x7c, 0xf2,
    0x23, 0xf6, 0xeb, 0x5a,
];
const HV_KEY_10: [u8; 16] = [
    0x02, 0x1a, 0x83, 0xf3, 0x97, 0xe9, 0xd4, 0xb8, 0x06, 0x74, 0x14, 0x6b,
    0x30, 0x4c, 0x00, 0x91,
];
const HV_KEY_11: [u8; 16] = [
    0x42, 0x66, 0x37, 0xb3, 0x68, 0x05, 0x9f, 0x85, 0x6e, 0x96, 0xbd, 0x1e,
    0xf9, 0x0e, 0x7f, 0xbd,
];

const HIDDEN_KEYS: [[u8; 32]; 12] = [
    [
        0x7f, 0x95, 0x5b, 0x9d, 0x94, 0xba, 0x12, 0xf1, 0xd7, 0x5a, 0x67, 0xd9,
        0x16, 0x45, 0x28, 0xdd, 0x61, 0x55, 0x55, 0xaf, 0x23, 0x91, 0xd6, 0x0a,
        0x3a, 0x42, 0x81, 0x18, 0xb4, 0xf7, 0xf3, 0x04,
    ],
    [
        0x78, 0x96, 0x5d, 0x92, 0x92, 0xb0, 0x47, 0xac, 0x8f, 0x5b, 0x6d, 0xdc,
        0x1c, 0x41, 0x7e, 0xda, 0x6a, 0x55, 0x53, 0xaf, 0x20, 0xc8, 0xdc, 0x0a,
        0x66, 0x43, 0xdd, 0x1c, 0xb2, 0xa5, 0xa4, 0x0c,
    ],
    [
        0x7e, 0x92, 0x5c, 0x93, 0x90, 0xed, 0x4a, 0xad, 0x8b, 0x07, 0x36, 0xd3,
        0x10, 0x41, 0x78, 0x8f, 0x60, 0x08, 0x55, 0xa8, 0x26, 0xcf, 0xd0, 0x0f,
        0x65, 0x11, 0x84, 0x45, 0xb1, 0xa0, 0xfa, 0x57,
    ],
    [
        0x79, 0x97, 0x0b, 0x90, 0x92, 0xb0, 0x44, 0xad, 0x8a, 0x0e, 0x60, 0xd9,
        0x14, 0x11, 0x7e, 0x8d, 0x35, 0x5d, 0x5c, 0xfb, 0x21, 0x9c, 0xd3, 0x0e,
        0x32, 0x40, 0xd1, 0x48, 0xb8, 0xa7, 0xa1, 0x0d,
    ],
    [
        0x28, 0xc3, 0x5d, 0x97, 0xc1, 0xec, 0x42, 0xf1, 0xdc, 0x5d, 0x37, 0xda,
        0x14, 0x47, 0x79, 0x8a, 0x32, 0x5c, 0x54, 0xf2, 0x72, 0x9d, 0xd3, 0x0d,
        0x67, 0x4c, 0xd6, 0x49, 0xb4, 0xa2, 0xf3, 0x50,
    ],
    [
        0x28, 0x96, 0x5e, 0x95, 0xc5, 0xe9, 0x45, 0xad, 0x8a, 0x5d, 0x64, 0x8e,
        0x17, 0x40, 0x2e, 0x87, 0x36, 0x58, 0x06, 0xfd, 0x75, 0x90, 0xd0, 0x5f,
        0x3a, 0x40, 0xd4, 0x4c, 0xb0, 0xf7, 0xa7, 0x04,
    ],
    [
        0x2c, 0x96, 0x01, 0x96, 0x9b, 0xbc, 0x15, 0xa6, 0xde, 0x0e, 0x65, 0x8d,
        0x17, 0x47, 0x2f, 0xdd, 0x63, 0x54, 0x55, 0xaf, 0x76, 0xca, 0x84, 0x5f,
        0x62, 0x44, 0x80, 0x4a, 0xb3, 0xf4, 0xf4, 0x0c,
    ],
    [
        0x7e, 0xc4, 0x0e, 0xc6, 0x9a, 0xeb, 0x43, 0xa0, 0xdb, 0x0a, 0x64, 0xdf,
        0x1c, 0x42, 0x24, 0x89, 0x63, 0x5c, 0x55, 0xf3, 0x71, 0x90, 0xdc, 0x5d,
        0x60, 0x40, 0xd1, 0x4d, 0xb2, 0xa3, 0xa7, 0x0d,
    ],
    [
        0x2c, 0x9a, 0x0b, 0x90, 0x9a, 0xbe, 0x47, 0xa7, 0x88, 0x5a, 0x6d, 0xdf,
        0x13, 0x1d, 0x2e, 0x8b, 0x60, 0x5e, 0x55, 0xf2, 0x74, 0x9c, 0xd7, 0x0e,
        0x60, 0x40, 0x80, 0x1c, 0xb7, 0xa1, 0xf4, 0x02,
    ],
    [
        0x28, 0x96, 0x5b, 0x95, 0xc1, 0xe9, 0x40, 0xa3, 0x8f, 0x0c, 0x32, 0xdf,
        0x43, 0x1d, 0x24, 0x8d, 0x61, 0x09, 0x54, 0xab, 0x27, 0x9a, 0xd3, 0x58,
        0x60, 0x16, 0x84, 0x4f, 0xb3, 0xa4, 0xf3, 0x0d,
    ],
    [
        0x25, 0x93, 0x08, 0xc0, 0x9a, 0xbd, 0x10, 0xa2, 0xd6, 0x09, 0x60, 0x8f,
        0x11, 0x1d, 0x7a, 0x8f, 0x63, 0x0b, 0x5d, 0xf2, 0x21, 0xec, 0xd7, 0x08,
        0x62, 0x40, 0x84, 0x49, 0xb0, 0xad, 0xf2, 0x07,
    ],
    [
        0x29, 0xc3, 0x0c, 0x96, 0x96, 0xeb, 0x10, 0xa0, 0xda, 0x59, 0x32, 0xd3,
        0x17, 0x41, 0x25, 0xdc, 0x63, 0x08, 0x04, 0xae, 0x77, 0xcb, 0x84, 0x5a,
        0x60, 0x4d, 0xdd, 0x45, 0xb5, 0xf4, 0xa0, 0x05,
    ],
];

// arby 4
const HIDDEN_KEYS_17_1: [[u8; 32]; 12] = [
    [
        0x4c, 0x22, 0xd9, 0x28, 0xa6, 0x23, 0x01, 0x62, 0x0a, 0x84, 0x86, 0x27,
        0xbb, 0xcc, 0x88, 0x9e, 0x33, 0x3a, 0x6b, 0x23, 0x92, 0x22, 0xa2, 0xb4,
        0x81, 0x64, 0x4e, 0x8d, 0x25, 0x69, 0x9f, 0xdc,
    ],
    [
        0x64, 0xf1, 0x5f, 0x54, 0xca, 0x70, 0xb8, 0x8b, 0xf8, 0xaa, 0x2a, 0xd3,
        0xd9, 0xec, 0x3b, 0x49, 0xe8, 0x0a, 0x3e, 0xe3, 0x46, 0xb1, 0xbf, 0x27,
        0x1b, 0x6c, 0x76, 0x11, 0xc8, 0x35, 0x7a, 0xb4,
    ],
    [
        0x74, 0xf7, 0x42, 0xa5, 0xf1, 0xc7, 0x56, 0x2d, 0x31, 0xe1, 0x73, 0xf9,
        0x96, 0x93, 0x89, 0x85, 0xa7, 0xac, 0x34, 0x46, 0x68, 0xd0, 0xbd, 0x6e,
        0x08, 0xff, 0x5e, 0x8a, 0xae, 0x93, 0xa2, 0xdb,
    ],
    [
        0xf8, 0xa3, 0x21, 0x5c, 0xc2, 0xbf, 0xc1, 0xc0, 0xaf, 0x79, 0x1d, 0x96,
        0x43, 0x43, 0xd5, 0xf9, 0x8f, 0xd9, 0xc8, 0xc9, 0xce, 0x6e, 0x68, 0x93,
        0x32, 0x5c, 0x80, 0xfa, 0x18, 0xe4, 0x3a, 0x06,
    ],
    [
        0x8d, 0x99, 0x57, 0xb0, 0x0d, 0xe0, 0x26, 0xdc, 0xda, 0xd3, 0xda, 0x2b,
        0x03, 0x74, 0x35, 0xc3, 0xfa, 0x23, 0x4e, 0x96, 0x62, 0xea, 0xf0, 0xd4,
        0xc6, 0xc7, 0x7f, 0x6e, 0xba, 0xa9, 0x42, 0x7d,
    ],
    [
        0xb1, 0x70, 0x75, 0x8c, 0x92, 0x76, 0xb6, 0x3c, 0xfb, 0x72, 0x78, 0x7c,
        0x19, 0x5e, 0x31, 0xa5, 0x0c, 0x6a, 0x1e, 0x24, 0x79, 0x51, 0x85, 0xa0,
        0x53, 0xe4, 0x3e, 0xc2, 0x86, 0x15, 0x25, 0xba,
    ],
    [
        0x19, 0xb1, 0xbc, 0x30, 0x61, 0x7e, 0x84, 0x06, 0x34, 0xb9, 0x81, 0xa9,
        0x5d, 0xd3, 0x4c, 0x86, 0x2b, 0xb1, 0xd4, 0xa9, 0xf0, 0x21, 0xfb, 0x61,
        0xfe, 0x8b, 0x26, 0x83, 0x92, 0x20, 0xe6, 0xbc,
    ],
    [
        0x49, 0x1a, 0xbd, 0xc3, 0xdb, 0x75, 0x30, 0x22, 0x84, 0x11, 0xc8, 0x1c,
        0x33, 0xe8, 0x4d, 0x5a, 0x34, 0x79, 0xc3, 0x9f, 0xed, 0x8f, 0x81, 0xf6,
        0xb3, 0xa5, 0xe8, 0xe1, 0x04, 0xee, 0x3a, 0xf0,
    ],
    [
        0x44, 0xb1, 0x0a, 0x9f, 0x80, 0x9a, 0xb0, 0x20, 0x4c, 0x16, 0xc7, 0x9c,
        0xc9, 0x78, 0x84, 0xa9, 0x92, 0xc7, 0xea, 0x53, 0x81, 0x4e, 0xc3, 0xcc,
        0x2f, 0x0b, 0x0c, 0x86, 0xe0, 0x8d, 0xa5, 0x02,
    ],
    [
        0xdf, 0x64, 0x2a, 0x87, 0xcb, 0xa7, 0x22, 0xd5, 0xff, 0x9c, 0x8d, 0x58,
        0xc9, 0x89, 0x35, 0x38, 0x79, 0xa4, 0x09, 0xc8, 0x2e, 0xe8, 0xb5, 0x90,
        0x8a, 0xe9, 0xd3, 0xa3, 0x2d, 0x49, 0x71, 0x9c,
    ],
    [
        0x04, 0xec, 0xc2, 0x82, 0x0e, 0x61, 0xab, 0xb3, 0x4b, 0x4c, 0x6c, 0x10,
        0xe5, 0xfa, 0x8f, 0xc7, 0xdd, 0xa5, 0x45, 0x16, 0x5c, 0x37, 0xcf, 0x70,
        0xe9, 0xfe, 0x5d, 0x9b, 0xe6, 0xb2, 0xa5, 0x85,
    ],
    [
        0xb3, 0xcc, 0x1c, 0xaa, 0x9a, 0x16, 0x32, 0xe7, 0x0c, 0x41, 0xc0, 0xbd,
        0x70, 0x1e, 0xbc, 0x72, 0x17, 0xcb, 0x04, 0x6b, 0x14, 0x00, 0x13, 0xb6,
        0x37, 0x33, 0xa3, 0xb7, 0xd3, 0xdd, 0xc9, 0x1a,
    ],
];

// mix drop
const HIDDEN_KEYS_17_4: [[u8; 32]; 12] = [
    [
        0x53, 0xb6, 0x2e, 0xf4, 0xe7, 0xec, 0x46, 0x0a, 0xd2, 0xa7, 0x9a, 0xb7,
        0x6f, 0x00, 0xb6, 0xe8, 0x04, 0x6d, 0x28, 0xd0, 0xf3, 0xaf, 0xa6, 0x5d,
        0xe5, 0x27, 0xb9, 0x06, 0xb6, 0x69, 0xa2, 0xd6,
    ],
    [
        0x1b, 0xf1, 0x33, 0x88, 0xc6, 0xce, 0x99, 0xf8, 0x72, 0x3a, 0x39, 0x94,
        0xdc, 0x59, 0x74, 0x9c, 0x41, 0x91, 0x65, 0xc9, 0x55, 0xd6, 0x4c, 0xa6,
        0x52, 0x05, 0xd7, 0xab, 0xe9, 0xda, 0x3d, 0x5c,
    ],
    [
        0xda, 0x56, 0x1b, 0xb6, 0x2b, 0xc1, 0x22, 0x91, 0x06, 0xb2, 0xa6, 0x5c,
        0xbc, 0x4f, 0x50, 0x4b, 0x3d, 0x6a, 0x11, 0xcd, 0xca, 0xea, 0xab, 0x5b,
        0x69, 0x8c, 0xbf, 0x93, 0xd3, 0xf7, 0x55, 0xe6,
    ],
    [
        0x73, 0x92, 0xc9, 0xd9, 0xe3, 0x52, 0x5d, 0x56, 0x74, 0x73, 0xf8, 0xaa,
        0xcf, 0xcb, 0xef, 0x5d, 0xe9, 0xc8, 0x97, 0x96, 0xdc, 0x7e, 0xc7, 0xf7,
        0xd4, 0x83, 0x9b, 0x9d, 0x90, 0x06, 0xb5, 0x60,
    ],
    [
        0x77, 0x99, 0xa9, 0x0f, 0x83, 0x9b, 0x1a, 0xdd, 0xbc, 0x60, 0x53, 0xee,
        0xf4, 0xfa, 0x77, 0x96, 0xd0, 0x0f, 0x8f, 0x4b, 0xbb, 0x2e, 0x83, 0xf5,
        0x19, 0x27, 0xc2, 0xa8, 0x10, 0x40, 0xf0, 0xf3,
    ],
    [
        0xaa, 0xe1, 0x9d, 0xf1, 0x60, 0x38, 0xf9, 0xe1, 0x34, 0x10, 0xa7, 0x85,
        0xe3, 0x9a, 0x77, 0xc7, 0x11, 0x9c, 0xeb, 0x71, 0x71, 0xc1, 0x2b, 0x0e,
        0x95, 0x2e, 0x0c, 0xa7, 0x94, 0x69, 0x0b, 0x56,
    ],
    [
        0x86, 0x62, 0xf2, 0x77, 0xd0, 0x33, 0x90, 0x58, 0xf8, 0x22, 0xe3, 0xdd,
        0x48, 0xb4, 0x98, 0xfe, 0x9e, 0xdf, 0x47, 0x72, 0xa8, 0x38, 0x15, 0x3d,
        0x8b, 0x11, 0xe3, 0xdd, 0xff, 0xf9, 0x54, 0x9d,
    ],
    [
        0xa3, 0x2e, 0xe6, 0x54, 0x34, 0x94, 0x8f, 0x3d, 0x6c, 0x78, 0xc0, 0x06,
        0x28, 0xe9, 0x84, 0x5a, 0x80, 0xb8, 0xbe, 0xbb, 0x03, 0xb1, 0x1b, 0xb6,
        0xdc, 0xb6, 0x4c, 0xd5, 0xe2, 0xbf, 0x78, 0x2f,
    ],
    [
        0x35, 0x81, 0x86, 0xc9, 0x42, 0xcb, 0x1b, 0x2b, 0x87, 0x32, 0xae, 0x98,
        0x73, 0x8e, 0xce, 0x02, 0xa7, 0x88, 0x2c, 0xbe, 0xfa, 0x54, 0x9d, 0x84,
        0xbe, 0xc4, 0x0b, 0xff, 0xe6, 0xd9, 0x18, 0x2e,
    ],
    [
        0xca, 0x53, 0xb0, 0x5f, 0x14, 0x3a, 0x40, 0xb2, 0x5f, 0x8d, 0x5e, 0x10,
        0x86, 0x0d, 0x63, 0xbd, 0xc7, 0x4b, 0x71, 0xd6, 0xff, 0xdd, 0x2d, 0x1f,
        0xd9, 0x06, 0x20, 0xf6, 0xf8, 0x2f, 0x7d, 0x56,
    ],
    [
        0x40, 0x2f, 0x93, 0x66, 0x9b, 0xee, 0x29, 0x5c, 0x91, 0xcf, 0xa6, 0xad,
        0x47, 0x63, 0x01, 0x87, 0x51, 0x6c, 0xe8, 0x29, 0x55, 0x68, 0x5e, 0x11,
        0xc2, 0x48, 0x23, 0x96, 0x05, 0x78, 0xb3, 0xa1,
    ],
    [
        0x8f, 0xfb, 0x7e, 0xad, 0x69, 0x6a, 0x24, 0xcd, 0x03, 0x97, 0xca, 0xb8,
        0x48, 0x39, 0xf6, 0xdd, 0x56, 0x80, 0x61, 0xe7, 0x66, 0xee, 0x5c, 0x55,
        0xd1, 0x52, 0x57, 0xce, 0xd2, 0xc0, 0xbe, 0xc1,
    ],
];

// virtual just dance
const HIDDEN_KEYS_17_6: [[u8; 32]; 12] = [
    [
        0x35, 0xb3, 0xda, 0x45, 0x95, 0xd2, 0x5c, 0x4e, 0x65, 0x01, 0x5f, 0x84,
        0x61, 0x61, 0x6a, 0x08, 0xb0, 0x0d, 0x41, 0xd3, 0xa7, 0xf4, 0xb8, 0xa1,
        0x78, 0x08, 0xe2, 0x75, 0x29, 0x1e, 0xfe, 0x8d,
    ],
    [
        0x18, 0x9a, 0x4c, 0x81, 0x2e, 0x8a, 0x6d, 0x40, 0x17, 0xec, 0x55, 0x1b,
        0x4b, 0x39, 0x28, 0x84, 0x63, 0x69, 0xc3, 0x6b, 0x24, 0x30, 0x71, 0x00,
        0xcd, 0x0e, 0xdd, 0xda, 0xa1, 0xfa, 0x1b, 0xb9,
    ],
    [
        0x41, 0xc7, 0x6e, 0xe3, 0x6d, 0xda, 0xb1, 0x96, 0x7c, 0x19, 0x0f, 0x98,
        0x6e, 0x12, 0xb3, 0x41, 0x99, 0x0f, 0xd5, 0x4c, 0x32, 0x7e, 0x9f, 0xba,
        0x0b, 0x5f, 0xe7, 0xa1, 0x5b, 0x73, 0x59, 0x8b,
    ],
    [
        0xff, 0x37, 0xa5, 0x37, 0x8a, 0xf7, 0x8d, 0xa8, 0xf1, 0x21, 0xfe, 0xfb,
        0xc1, 0x08, 0x2f, 0x30, 0x84, 0xc2, 0x4f, 0x6c, 0x00, 0x32, 0x9f, 0xa7,
        0xcb, 0x7f, 0xb8, 0x15, 0x51, 0x4f, 0xd7, 0xeb,
    ],
    [
        0x29, 0x5b, 0xaa, 0x6a, 0x41, 0xca, 0xc8, 0xff, 0xbf, 0x9b, 0x4e, 0x0f,
        0xcc, 0x29, 0xc6, 0x92, 0x15, 0x8e, 0xec, 0x97, 0x60, 0xc7, 0xa9, 0x68,
        0x40, 0x61, 0x89, 0x29, 0x8e, 0x5a, 0x05, 0x50,
    ],
    [
        0x4e, 0x08, 0x6a, 0x65, 0x42, 0x6e, 0x89, 0x63, 0xf1, 0xc3, 0x45, 0x06,
        0xb0, 0x52, 0xe9, 0xba, 0x9e, 0xec, 0x6f, 0x9a, 0x99, 0x4d, 0x07, 0xe7,
        0x8a, 0x1b, 0x03, 0x2f, 0xd1, 0x07, 0xe7, 0xd4,
    ],
    [
        0x57, 0x12, 0x80, 0xf2, 0x74, 0x43, 0x60, 0x68, 0x17, 0xac, 0x2f, 0xca,
        0x55, 0x2b, 0x0d, 0x36, 0x16, 0xb8, 0xd6, 0x45, 0xe3, 0xd8, 0x4c, 0x8f,
        0xd7, 0x8d, 0x25, 0xeb, 0x4a, 0x2b, 0x07, 0xd5,
    ],
    [
        0x8c, 0xdf, 0xb8, 0xa6, 0x1e, 0x94, 0x4f, 0x9a, 0x10, 0x80, 0x67, 0xe2,
        0x0d, 0x61, 0xbb, 0xa7, 0x54, 0x83, 0xac, 0x2e, 0xfa, 0xda, 0xee, 0xd4,
        0xc4, 0x5a, 0x77, 0xce, 0xae, 0x03, 0x17, 0xb6,
    ],
    [
        0x44, 0x34, 0x3f, 0xa8, 0x66, 0x5d, 0x85, 0x17, 0xc1, 0xda, 0x8d, 0x26,
        0xb3, 0x33, 0xba, 0x87, 0x57, 0x10, 0x6c, 0xb9, 0x7e, 0x43, 0xcb, 0x97,
        0xfd, 0x2e, 0x48, 0xdc, 0x3d, 0xa4, 0xbf, 0x8a,
    ],
    [
        0xbb, 0x9a, 0x0e, 0x29, 0x7d, 0x8d, 0x17, 0x46, 0x08, 0x61, 0x8e, 0x72,
        0xab, 0xef, 0x4b, 0x40, 0xc4, 0x93, 0x24, 0x03, 0x21, 0x54, 0x02, 0x97,
        0xb5, 0x12, 0xab, 0x42, 0x4f, 0x23, 0x2a, 0x6f,
    ],
    [
        0x7b, 0xd5, 0x0c, 0x35, 0xe3, 0x62, 0xe4, 0x3b, 0xee, 0x23, 0x30, 0x9e,
        0x61, 0x70, 0xbe, 0xbf, 0x8f, 0xa7, 0x4b, 0xed, 0x97, 0x3b, 0xd1, 0xcb,
        0xdd, 0xd2, 0x0b, 0xe5, 0xe1, 0xb9, 0xe6, 0x52,
    ],
    [
        0x69, 0xa9, 0x4b, 0x0f, 0x1c, 0x58, 0xcb, 0x77, 0xe2, 0x12, 0xea, 0x94,
        0xdf, 0x47, 0x3f, 0x53, 0x26, 0xba, 0x0e, 0x6e, 0x09, 0xc3, 0xb2, 0x22,
        0x68, 0xdd, 0x4c, 0x5c, 0xfd, 0x66, 0x86, 0x73,
    ],
];

// audi car
const HIDDEN_KEYS_17_8: [[u8; 32]; 12] = [
    [
        0x9e, 0xdf, 0xa5, 0xbb, 0x02, 0xca, 0x0c, 0x2b, 0x51, 0x02, 0x1a, 0x35,
        0x11, 0x62, 0x8a, 0x0f, 0x66, 0x31, 0x6e, 0x73, 0x0a, 0x68, 0x5f, 0x55,
        0xe0, 0x51, 0x4f, 0x73, 0x50, 0x53, 0xb4, 0x9c,
    ],
    [
        0x98, 0x3a, 0xfa, 0x87, 0x4c, 0x44, 0x70, 0xa8, 0x15, 0xe4, 0x5a, 0x85,
        0x73, 0xae, 0x1a, 0x32, 0x26, 0x63, 0x28, 0x11, 0x4d, 0x80, 0x73, 0xab,
        0x3d, 0x86, 0x9c, 0x03, 0x99, 0xac, 0x10, 0x1a,
    ],
    [
        0xa4, 0xb6, 0xa4, 0xfc, 0x5a, 0xec, 0x7a, 0x18, 0xc0, 0x2c, 0x79, 0x74,
        0xe2, 0xdb, 0x35, 0x14, 0x02, 0xfe, 0x91, 0x0e, 0x13, 0xa9, 0x44, 0xdf,
        0x94, 0x85, 0x3f, 0x9a, 0x41, 0xcb, 0x34, 0x32,
    ],
    [
        0x7b, 0x87, 0xc0, 0xf6, 0xae, 0xf6, 0x44, 0x10, 0xd2, 0x01, 0xaf, 0x18,
        0x67, 0x98, 0xc2, 0x0e, 0xec, 0x9a, 0x41, 0x42, 0xea, 0x90, 0xef, 0xde,
        0xd6, 0xbf, 0x12, 0x6c, 0x8b, 0x2b, 0x6e, 0x13,
    ],
    [
        0x63, 0xe9, 0xb0, 0x24, 0xd2, 0x0f, 0xc1, 0x3c, 0x6f, 0x60, 0xec, 0xd6,
        0xce, 0x9a, 0xcc, 0x7d, 0x25, 0x04, 0x95, 0x81, 0x9d, 0xb9, 0x9a, 0xf1,
        0x8b, 0x82, 0x1f, 0xf9, 0xa3, 0xa6, 0x2b, 0x3a,
    ],
    [
        0xc1, 0x5d, 0xa1, 0xd2, 0x49, 0x92, 0x02, 0x8d, 0x76, 0x7a, 0x32, 0x76,
        0xb7, 0xfd, 0x64, 0xcb, 0x51, 0x2d, 0x51, 0xc7, 0xfc, 0x0e, 0x2f, 0xa4,
        0xf8, 0x1d, 0xf1, 0x02, 0x81, 0x88, 0x49, 0x4f,
    ],
    [
        0x0a, 0xfc, 0xcb, 0x82, 0x34, 0xad, 0x23, 0xdb, 0x13, 0x1b, 0x4b, 0x7a,
        0xa4, 0xd6, 0x26, 0xfa, 0xdf, 0x86, 0x65, 0x64, 0xb0, 0x6f, 0x95, 0x84,
        0x92, 0xd0, 0x4d, 0x31, 0x68, 0x61, 0x56, 0x21,
    ],
    [
        0xdf, 0x60, 0xee, 0xdb, 0xc5, 0x55, 0x26, 0xc0, 0x0e, 0x3f, 0xa8, 0x4b,
        0xd4, 0xb1, 0x54, 0x3f, 0x60, 0x93, 0xbf, 0xb3, 0x8a, 0x46, 0x79, 0x34,
        0x36, 0xa9, 0x16, 0x9d, 0x20, 0xf7, 0xd3, 0x61,
    ],
    [
        0x92, 0x63, 0x1e, 0x54, 0xe4, 0xdf, 0x9b, 0x42, 0x32, 0xb4, 0xa8, 0x3d,
        0x2e, 0x48, 0x3a, 0x96, 0x89, 0x0f, 0xcf, 0xaa, 0x22, 0x09, 0x1d, 0xd3,
        0xf9, 0x28, 0x25, 0xce, 0x67, 0x57, 0xd6, 0xd0,
    ],
    [
        0xc1, 0x30, 0x1d, 0x91, 0xa1, 0xb7, 0x39, 0x1e, 0xe4, 0xd9, 0x08, 0x88,
        0xcd, 0x19, 0x88, 0x09, 0xfc, 0xc1, 0x38, 0x59, 0x7c, 0x4b, 0xd7, 0xd9,
        0xf5, 0x10, 0xa3, 0x9c, 0x1e, 0x5e, 0xf1, 0x30,
    ],
    [
        0x36, 0x00, 0x3f, 0x13, 0xa0, 0x7a, 0xb6, 0x02, 0x86, 0x4d, 0xc2, 0x70,
        0x19, 0x1f, 0xd1, 0xd9, 0x8e, 0x0b, 0x64, 0x4a, 0xf2, 0xc6, 0xeb, 0xb5,
        0x1c, 0x14, 0x6c, 0xc0, 0x54, 0xd3, 0x69, 0x5c,
    ],
    [
        0x00, 0xb1, 0xa8, 0x7f, 0xa2, 0x91, 0xad, 0x8e, 0x08, 0xf6, 0xc9, 0x03,
        0x71, 0xa9, 0x74, 0x64, 0x66, 0xde, 0x4e, 0x02, 0x08, 0x35, 0x39, 0x40,
        0x9c, 0x75, 0x10, 0x0d, 0x9d, 0x61, 0x7f, 0x63,
    ],
];

//blown fuses
const HIDDEN_KEYS_17_10: [[u8; 32]; 12] = [
    [
        0xfe, 0x0e, 0x46, 0xa5, 0x59, 0x14, 0x7c, 0x30, 0xb4, 0x6a, 0x42, 0xcb,
        0x75, 0x71, 0xbb, 0xcd, 0xd8, 0xc3, 0x20, 0xdc, 0x2e, 0xf7, 0x02, 0x8b,
        0x03, 0x36, 0x43, 0x96, 0xaf, 0xde, 0x2d, 0x71,
    ],
    [
        0xaf, 0xa3, 0xf3, 0x3b, 0xdb, 0x8f, 0xe2, 0xf5, 0x96, 0x45, 0x8a, 0x37,
        0xed, 0xb9, 0xab, 0x18, 0x1f, 0xb2, 0xdd, 0x75, 0xa6, 0x2a, 0x66, 0xe6,
        0xc4, 0xc1, 0x44, 0xf4, 0x78, 0x15, 0x9f, 0x38,
    ],
    [
        0xe9, 0x61, 0x9c, 0x1c, 0x51, 0x16, 0x49, 0x77, 0xb3, 0xe3, 0xc5, 0xf9,
        0x57, 0x73, 0x78, 0xee, 0x72, 0xa5, 0x11, 0x24, 0x0e, 0xd6, 0x81, 0x85,
        0xf1, 0xb7, 0xd7, 0x09, 0x0a, 0x95, 0x04, 0x82,
    ],
    [
        0xb5, 0x82, 0x8b, 0xc7, 0x2b, 0x0b, 0xe8, 0x45, 0x23, 0x5a, 0xe7, 0xb4,
        0xe4, 0x32, 0x59, 0x82, 0xb0, 0x89, 0x2f, 0xc8, 0x0f, 0x53, 0xbd, 0x1c,
        0xda, 0x9b, 0x8e, 0x28, 0x6f, 0x0f, 0x7e, 0xf0,
    ],
    [
        0x54, 0x1d, 0x9e, 0xbc, 0x51, 0xdf, 0x27, 0x95, 0xa4, 0x3f, 0xcc, 0xcb,
        0xb4, 0x1c, 0x3d, 0x60, 0x15, 0xef, 0x5d, 0x3e, 0x46, 0x3d, 0x2b, 0x17,
        0x98, 0x97, 0x89, 0xa0, 0x7f, 0xf1, 0x59, 0xa3,
    ],
    [
        0xf2, 0xe9, 0xb4, 0x72, 0xf2, 0x65, 0x22, 0xa3, 0x38, 0x1a, 0xdd, 0xe3,
        0x83, 0xed, 0x95, 0xd1, 0x6e, 0xcf, 0xc6, 0xeb, 0x87, 0x63, 0x4f, 0x71,
        0x85, 0xa9, 0x15, 0x62, 0x43, 0x6c, 0x18, 0x98,
    ],
    [
        0x25, 0x8b, 0xfa, 0xf6, 0xfc, 0x92, 0x38, 0x9e, 0xbf, 0x53, 0x45, 0x33,
        0xab, 0x9c, 0xcd, 0x53, 0x41, 0x79, 0xc3, 0x27, 0x50, 0xbc, 0xd2, 0x47,
        0x3a, 0x49, 0x39, 0xf9, 0x87, 0x54, 0x8f, 0xfe,
    ],
    [
        0x29, 0x5a, 0xea, 0xba, 0x0a, 0xef, 0x1f, 0xcd, 0x22, 0x1e, 0x48, 0x3e,
        0x70, 0xf0, 0x62, 0x21, 0x8c, 0x83, 0xf6, 0x8a, 0x10, 0x3b, 0x55, 0x6e,
        0xb5, 0x35, 0xbb, 0x70, 0x4f, 0xec, 0xa1, 0xfb,
    ],
    [
        0x08, 0x2c, 0x3a, 0xec, 0x3f, 0xfa, 0x71, 0xb7, 0x25, 0x3c, 0x4b, 0xfc,
        0xe5, 0x5c, 0xaf, 0x6b, 0x31, 0x43, 0x05, 0x73, 0x99, 0xb3, 0x56, 0xf7,
        0xcd, 0xe5, 0x44, 0x81, 0x81, 0x97, 0xba, 0xd9,
    ],
    [
        0x03, 0x4d, 0xd2, 0xf2, 0x44, 0xb6, 0x8f, 0xa2, 0x94, 0xfd, 0x8d, 0x0b,
        0x22, 0x97, 0x91, 0x50, 0xb4, 0xaf, 0x5a, 0xd2, 0x92, 0x94, 0x6b, 0xa3,
        0x55, 0x56, 0xa8, 0xe5, 0x3f, 0x5c, 0xdd, 0x4f,
    ],
    [
        0x81, 0x84, 0x19, 0x91, 0x45, 0x40, 0x3f, 0x9d, 0x7c, 0x47, 0xf4, 0x5d,
        0x57, 0x56, 0x80, 0x30, 0xd9, 0x98, 0x1c, 0x65, 0x5e, 0x07, 0xce, 0x9d,
        0xd1, 0x20, 0x62, 0x9d, 0x45, 0x8f, 0xbb, 0x0c,
    ],
    [
        0xb5, 0xa2, 0x15, 0x9d, 0x15, 0x86, 0x9f, 0x6e, 0x80, 0x55, 0x8c, 0xe6,
        0x6c, 0x68, 0x71, 0xee, 0x7e, 0xed, 0x19, 0x9c, 0xb0, 0x80, 0xc5, 0x5f,
        0xdc, 0x9f, 0xd1, 0x4a, 0x01, 0x36, 0xf4, 0x39,
    ],
];

fn do_crypt(
    key: &[u8; 16],
    mogg_data: &mut [u8],
    file_nonce: &[u8; 16],
    ogg_offset: usize,
) {
    let aes = Aes128::new(key.into());
    // avoid clobbering the nonce for rn
    let mut nonce = file_nonce.to_owned();
    let mut block_mask = [0u8; 16];
    aes.encrypt_block_b2b(
        GenericArray::from_slice(&nonce),
        GenericArray::from_mut_slice(&mut block_mask),
    );
    let mut block_offset = 0;
    for byte in mogg_data.iter_mut().skip(ogg_offset) {
        if block_offset == 16 {
            for j in &mut nonce {
                *j = j.wrapping_add(1);
                if *j != 0 {
                    break;
                }
            }
            aes.encrypt_block_b2b(
                GenericArray::from_slice(&nonce),
                GenericArray::from_mut_slice(&mut block_mask),
            );
            block_offset = 0;
        }

        *byte ^= block_mask[block_offset];
        block_offset += 1;
    }
}

fn get_masher() -> [u8; 32] {
    let mut m_masher_word: i32;
    let mut masher_word: i32 = 0xeb;
    let mut masher = [0i32; 8];

    for (idx, word) in masher.iter_mut().enumerate() {
        m_masher_word = 0;
        if idx == 0 {
            m_masher_word = 0xeb;
        }
        if m_masher_word != 0 {
            masher_word = m_masher_word;
        }
        masher_word =
            masher_word.wrapping_mul(0x19660e).wrapping_add(0x3c6ef35f);
        *word = masher_word;
    }

    let mut out = Vec::new();

    for i in masher {
        out.append(&mut i.to_le_bytes().into())
    }

    out.try_into().unwrap()
}

fn read_u32_le<T: Read>(stream: &mut T) -> u32 {
    let mut buf = [0u8; 4];
    stream.read_exact(&mut buf).unwrap();
    u32::from_le_bytes(buf)
}

fn read_u64_le<T: Read>(stream: &mut T) -> u64 {
    let mut buf = [0u8; 8];
    stream.read_exact(&mut buf).unwrap();
    u64::from_le_bytes(buf)
}

fn gen_key(hv_key: &[u8; 16], mogg_data: &mut [u8], version: u32) -> [u8; 16] {
    debug!("generating ps3 key");
    let ps3 = gen_key_inner(hv_key, mogg_data, version, true);
    debug!("generating xbox 360 key");
    let x360 = gen_key_inner(hv_key, mogg_data, version, false);

    if ps3 != x360 {
        warn!("PS3 key does not match Xbox 360 key");
    }
    x360
}

fn gen_key_inner(
    hv_key: &[u8; 16],
    mogg_data: &[u8],
    version: u32,
    ps3_path: bool,
) -> [u8; 16] {
    let mut mogg = Cursor::new(mogg_data);
    let mut key_mask_as_read = [0u8; 16];

    let masher = get_masher();
    debug!("masher: {}", hex::encode(masher));

    mogg.seek(SeekFrom::Start(16)).unwrap();
    let mut buf = [0u8; 4];
    mogg.read_exact(&mut buf).unwrap();
    let hmx_header_size = u32::from_le_bytes(buf) as u64;

    if ps3_path {
        mogg.seek(SeekFrom::Start(20 + hmx_header_size * 8 + 16 + 16))
            .unwrap();
    } else {
        mogg.seek(SeekFrom::Start(20 + hmx_header_size * 8 + 16 + 32))
            .unwrap();
    }

    mogg.read_exact(&mut key_mask_as_read).unwrap();

    debug!("key mask as read: {}", hex::encode(key_mask_as_read));

    let mut key_mask = [0u8; 16];

    if ps3_path {
        key_mask = key_mask_as_read
    } else {
        let aes_360 = Aes128::new(hv_key.into());
        match version {
            12..=17 => {
                aes_360.decrypt_block_b2b(
                    GenericArray::from_slice(&key_mask_as_read),
                    GenericArray::from_mut_slice(&mut key_mask),
                );
            }
            _ => unreachable!(),
        }
    }

    debug!("key mask: {}", hex::encode(key_mask));

    mogg.seek(SeekFrom::Start(20 + hmx_header_size * 8 + 16))
        .unwrap();
    let magic_a = read_u32_le(&mut mogg);

    mogg.seek(SeekFrom::Start(20 + hmx_header_size * 8 + 16 + 8))
        .unwrap();
    let magic_b = read_u32_le(&mut mogg);

    let mut use_new_hidden_keys = 0;

    mogg.seek(SeekFrom::Start(20 + hmx_header_size * 8 + 16 + 48))
        .unwrap();
    if version == 17 {
        use_new_hidden_keys = read_u64_le(&mut mogg);
        let v17_game = match use_new_hidden_keys {
            1 => "arby 4",
            4 => "mix drop",
            6 => "virtua just dance",
            8 => "audi car",
            10 => "blown fuse",
            _ => unimplemented!(),
        };
        debug!("use_new_hidden_keys: {use_new_hidden_keys} ({v17_game})");
    }

    let key_index_as_read = read_u64_le(&mut mogg);

    let key_index = if ps3_path {
        key_index_as_read % 6
    } else {
        key_index_as_read % 6 + 6
    };

    debug!("key index: {key_index}");

    let selected_key = match version {
        12..=16 => HIDDEN_KEYS[key_index as usize],
        17 => match use_new_hidden_keys {
            1 => HIDDEN_KEYS_17_1[key_index as usize],
            4 => HIDDEN_KEYS_17_4[key_index as usize],
            6 => HIDDEN_KEYS_17_6[key_index as usize],
            8 => HIDDEN_KEYS_17_8[key_index as usize],
            10 => HIDDEN_KEYS_17_10[key_index as usize],
            _ => unimplemented!(),
        },
        _ => unreachable!(),
    };

    debug!("selectedKey: {}", hex::encode(selected_key));

    let revealed_key = reveal_key(selected_key, masher);

    debug!("revealedKey: {}", hex::encode(revealed_key));

    let bytes_from_hex_string = hex_string_to_bytes(revealed_key);

    debug!("revealedKey char: {}", hex::encode(bytes_from_hex_string));

    let grind_array_result =
        grind_array(magic_a, magic_b, bytes_from_hex_string, version);

    debug!("grind_array_result: {}", hex::encode(grind_array_result));

    let mut key = [0u8; 16];
    for i in 0..16 {
        key[i] = grind_array_result[i] ^ key_mask[i];
    }

    debug!("key: {}", hex::encode(key));
    key
}

fn reveal_key(key: [u8; 32], masher: [u8; 32]) -> [u8; 32] {
    let mut key = key;
    for _ in 0..14 {
        supershuffle(&mut key);
    }

    key.iter()
        .zip(masher)
        .map(|(x, y)| *x ^ y)
        .collect::<Vec<u8>>()
        .try_into()
        .unwrap()
}

fn supershuffle(key: &mut [u8; 32]) {
    shuffle1(key);
    shuffle2(key);
    shuffle3(key);
    shuffle4(key);
    shuffle5(key);
    shuffle6(key);
}

fn shuffle1(key: &mut [u8; 32]) {
    for i in 0..8 {
        let offset = roll(i << 2);
        key.swap(offset, (i * 4) + 2);
        let offset = roll((i * 4) + 3);
        key.swap(offset, (i * 4) + 1);
    }
}

fn shuffle2(key: &mut [u8; 32]) {
    for i in 0..8 {
        key.swap(((7 - i) * 4) + 1, (i * 4) + 2);
        key.swap((7 - i) * 4, (i * 4) + 3);
    }
}

fn shuffle3(key: &mut [u8; 32]) {
    for i in 0..8 {
        let offset = roll(((7 - i) * 4) + 1);
        key.swap(offset, (i * 4) + 2);
        key.swap((7 - i) * 4, (i * 4) + 3);
    }
}

fn shuffle4(key: &mut [u8; 32]) {
    for i in 0..8 {
        key.swap(((7 - i) * 4) + 1, (i * 4) + 2);
        let offset = roll((7 - i) * 4);
        key.swap(offset, (i * 4) + 3);
    }
}

fn shuffle5(key: &mut [u8; 32]) {
    for i in 0..8 {
        let offset = roll((i * 4) + 2);
        key.swap(((7 - i) * 4) + 1, offset);
        key.swap((7 - i) * 4, (i * 4) + 3);
    }
}

fn shuffle6(key: &mut [u8; 32]) {
    for i in 0..8 {
        key.swap(((7 - i) * 4) + 1, (i * 4) + 2);
        let offset = roll((i * 4) + 3);
        key.swap((7 - i) * 4, offset);
    }
}

fn roll(x: usize) -> usize {
    (x + 0x13) % 0x20
}

fn ascii_digit_to_hex(h: u8) -> u8 {
    if !(0x61..=0x66).contains(&h) {
        if !(0x41..=0x46).contains(&h) {
            h.wrapping_sub(0x30)
        } else {
            h.wrapping_sub(0x37)
        }
    } else {
        h.wrapping_sub(87)
    }
}

fn hex_string_to_bytes(s: [u8; 32]) -> [u8; 16] {
    let mut arr = [0u8; 16];

    for i in 0..16 {
        let lo = ascii_digit_to_hex(s[i * 2 + 1]) as i32;
        let hi = ascii_digit_to_hex(s[i * 2]) as i32;
        arr[i] = (lo + hi * 16) as u8
    }
    arr
}

fn lcg(x: u32) -> u32 {
    x.wrapping_mul(0x19660d).wrapping_add(0x3c6ef35f)
}

fn grind_array(
    mut magic_a: u32,
    mut magic_b: u32,
    mut key: [u8; 16],
    version: u32,
) -> [u8; 16] {
    let mut _i: i32;
    let mut num: u32;
    let mut array = [0u8; 64];
    let mut array1 = [0u8; 64];
    let mut num1: u32 = magic_a;
    let num2: u32 = magic_b;
    let mut array2 = [0i32; 256];

    for item in &mut array2 {
        *item = (magic_a as u8 >> 3) as i32;
        magic_a = lcg(magic_a)
    }

    if magic_b == 0 {
        magic_b = 0x303f;
    }

    #[allow(clippy::needless_range_loop)]
    for i in 0..0x20 {
        loop {
            magic_b = lcg(magic_b);
            num = magic_b >> 2 & 0x1f;
            if array[num as usize] == 0 {
                break;
            }
        }
        array1[i] = num as u8;
        array[num as usize] = 1;
    }
    let mut array3 = array2;
    let mut array4 = [0i32; 256];
    magic_a = num2;

    for item in &mut array4 {
        *item = (magic_a as u8 >> 2 & 0x3f) as i32;
        magic_a = lcg(magic_a)
    }

    if version > 13 {
        #[allow(clippy::needless_range_loop)]
        for i in 32..64 {
            loop {
                num1 = lcg(num1);
                num = (num1 >> 2 & 0x1f) + 0x20;
                if array[num as usize] == 0 {
                    break;
                }
            }
            array1[i] = num as u8;
            array[num as usize] = 1;
        }
        array3 = array4;
    }
    for j in 0..16 {
        let mut num3 = key[j];
        for k in (0..16).step_by(2) {
            num3 = o_funcs(
                num3,
                key[k + 1],
                array1[array3[key[k] as usize] as usize],
            );
        }
        key[j] = num3;
    }
    key
}

fn rotr(x: i32, n: u32) -> i32 {
    u8::rotate_right(x as u8, n) as i32
}

fn rotl(x: i32, n: u32) -> i32 {
    u8::rotate_left(x as u8, n) as i32
}

fn not(x: i32) -> i32 {
    if x == 0 {
        1
    } else {
        0
    }
}

fn o_funcs(a1: u8, a2: u8, op: u8) -> u8 {
    let a1 = a1 as i32;
    let a2 = a2 as i32;
    let ret = match op {
        0 => a2 + rotr(a1, not(a2) as u32),
        1 => a2 + rotr(a1, 3),
        2 => a2 + rotl(a1, 1),
        3 => a2 ^ (a1 >> (a2 & 7 & 31) | (a1 << (-a2 & 7 & 31))),
        4 => a2 ^ rotl(a1, 4),
        5 => a2 + (a2 ^ rotr(a1, 3)),
        6 => a2 + rotl(a1, 2),
        7 => a2 + not(a1),
        8 => a2 ^ rotr(a1, not(a2) as u32),
        9 => a2 ^ (a2 + rotl(a1, 3)),
        10 => a2 + rotl(a1, 3),
        11 => a2 + rotl(a1, 4),
        12 => a1 ^ a2,
        13 => a2 ^ not(a1),
        14 => a2 ^ (a2 + rotr(a1, 3)),
        15 => a2 ^ rotl(a1, 3),
        16 => a2 ^ rotl(a1, 2),
        17 => a2 + (a2 ^ rotl(a1, 3)),
        18 => a2 + (a1 ^ a2),
        19 => a1 + a2,
        20 => a2 ^ rotr(a1, 3),
        21 => a2 ^ (a1 + a2),
        22 => rotr(a1, not(a2) as u32),
        23 => a2 + rotr(a1, 1),
        24 => a1 >> (a2 & 7 & 31) | a1 << (-a2 & 7 & 31),
        25 => {
            if a1 == 0 {
                if a2 == 0 {
                    128
                } else {
                    1
                }
            } else {
                0
            }
        }
        26 => a2 + rotr(a1, 2),
        27 => a2 ^ rotr(a1, 1),
        28 => o_funcs(!a1 as u8, a2 as u8, 24) as i32, // lmao
        29 => a2 ^ rotr(a1, 2),
        30 => a2 + (a1 >> (a2 & 7 & 31) | (a1 << (-a2 & 7 & 31))),
        31 => a2 ^ rotl(a1, 1),
        32 => ((a1 << 8 | 170 | a1 ^ 255) >> 4) ^ a2,
        33 => (a1 ^ 255 | a1 << 8) >> 3 ^ a2,
        34 => (a1 << 8 ^ 65280 | a1) >> 2 ^ a2,
        35 => (a1 ^ 92 | a1 << 8) >> 5 ^ a2,
        36 => (a1 << 8 | 101 | a1 ^ 60) >> 2 ^ a2,
        37 => (a1 ^ 54 | a1 << 8) >> 2 ^ a2,
        38 => (a1 ^ 54 | a1 << 8) >> 4 ^ a2,
        39 => (a1 ^ 92 | a1 << 8 | 54) >> 1 ^ a2,
        40 => (a1 ^ 255 | a1 << 8) >> 5 ^ a2,
        41 => (!a1 << 8 | a1) >> 6 ^ a2,
        42 => (a1 ^ 92 | a1 << 8) >> 3 ^ a2,
        43 => (a1 ^ 60 | 101 | a1 << 8) >> 5 ^ a2,
        44 => (a1 ^ 54 | a1 << 8) >> 1 ^ a2,
        45 => (a1 ^ 101 | a1 << 8 | 60) >> 6 ^ a2,
        46 => (a1 ^ 92 | a1 << 8) >> 2 ^ a2,
        47 => (a2 ^ 170 | a2 << 8 | 255) >> 3 ^ a1,
        48 => (a1 ^ 99 | a1 << 8 | 92) >> 6 ^ a2,
        49 => (a1 ^ 92 | a1 << 8 | 54) >> 7 ^ a2,
        50 => (a1 ^ 92 | a1 << 8) >> 6 ^ a2,
        51 => (a1 << 8 ^ 65280 | a1) >> 3 ^ a2,
        52 => (a1 ^ 255 | a1 << 8) >> 6 ^ a2,
        53 => (a1 << 8 ^ 65280 | a1) >> 5 ^ a2,
        54 => (a1 ^ 60 | 101 | a1 << 8) >> 4 ^ a2,
        55 => (a1 ^ 99 | a1 << 8 | 92) >> 3 ^ a2,
        56 => (a1 ^ 99 | a1 << 8 | 92) >> 5 ^ a2,
        57 => (a1 ^ 175 | a1 << 8 | 250) >> 5 ^ a2,
        58 => (a1 ^ 92 | a1 << 8 | 54) >> 5 ^ a2,
        59 => (a1 ^ 92 | a1 << 8 | 54) >> 3 ^ a2,
        60 => (a1 ^ 54 | a1 << 8) >> 3 ^ a2,
        61 => (a1 ^ 99 | a1 << 8 | 92) >> 4 ^ a2,
        62 => (a1 ^ 255 | a1 << 8 | 175) >> 6 ^ a2,
        63 => (a1 ^ 255 | a1 << 8) >> 2 ^ a2,
        _ => unreachable!(),
    };

    trace!("o_func: a1 {a1:2X}, a2: {a2:2X}, ret: {ret:2X}, op{op}");
    ret as u8
}

fn hmxa_to_ogg(mogg_data: &mut [u8], start: usize, num_entries: usize) {
    let magic_a = u32::from_le_bytes(
        mogg_data[20 + num_entries * 8 + 16..][..4]
            .try_into()
            .unwrap(),
    );
    let magic_b = u32::from_le_bytes(
        mogg_data[20 + num_entries * 8 + 16 + 8..][..4]
            .try_into()
            .unwrap(),
    );
    debug!("magic_a: {magic_a:08x}");
    debug!("magic_b: {magic_b:08x}");
    
    let magic_hash_a = lcg(lcg(magic_a ^ 0x5c5c5c5c));
    let magic_hash_b = lcg(magic_b ^ 0x36363636);

    debug!("magic_hash_a: {magic_hash_a:08x}");
    debug!("magic_hash_b: {magic_hash_b:08x}");
    
    mogg_data[start..][..4].copy_from_slice(&[0x4f, 0x67, 0x67, 0x53]);

    let slice_a = &mut mogg_data[start + 12..][..4];
    let val_a = u32::from_be_bytes(slice_a.try_into().unwrap());
    slice_a.copy_from_slice(&u32::to_be_bytes(val_a ^ magic_hash_a));

    let slice_b = &mut mogg_data[start + 20..][..4];
    let val_b = u32::from_be_bytes(slice_b.try_into().unwrap());
    slice_b.copy_from_slice(&u32::to_be_bytes(val_b ^ magic_hash_b));
}
